
% Attempt plotting figures where try different masses for single activation level
% for att = 1 : length(attenuations)
%     
%     modeled_v = cell(1, length(applied_forces));
%     modeled_y = cell(1, length(applied_forces));
%     modeled_t = cell(1, length(applied_forces));
%     modeled_a = cell(1, length(applied_forces));
%     modeled_f = cell(1, length(applied_forces));
%     
%     % get activation of fibers to use for attaching different masses to
%     dt = 0.1;
%     temp_t = 0 : dt : 1000;
%     sig = sigmoid(temp_t, [0.025, 500]);
%     sig(sig > attenuations(att)) = 0;
%     [~, idx] = max(sig);
%     att_t = idx * dt;
% 
%     [~, a] = ode45(@(t_a, a) dadt(t_a, a, params.tau, params.b), [0, att_t], [0, 0]');
%     a_slow = a(end, 1);
%     a_fast = a(end, 2);
%     modeled_a{att} = [a_slow, a_fast];
%     
%     % Model displacement and velocity for each mass and save
%     for app = 1 : length(applied_forces)
%         [t, y] = ode23(@(t, y) dYdt(t, y, a_slow, a_fast, best_params, l_opt_, v_0_, c_, theta_, applied_forces(app)), [0, 10], [0, 0]');
%         modeled_y{app} = y(:, 1)';
%         modeled_v{app} = y(:, 2)';
%         modeled_t{app} = t';
%     end
%     
%     % Use displacement and velocity to regenerate force production
%     for app = 1 : length(applied_forces)
%         force = zeros(1, length(modeled_t{app}));
%         for j = 1 : length(force)
%             f(j) = muscle_force(a_slow, a_fast, l_opt_+modeled_y{app}(j), l_opt_, modeled_v{app}(j), v_0_, k_, c_, theta_);
%         end
%         modeled_f{app} = force;
%     end
%     
%     figure;
%     subplot(1, 2, 1);
%     for m = 1 : length(applied_forces)
%         hold on;
%         plot(modeled_t{m}, modeled_v{m}.*1000);
%     end
%     title(sprintf('displacement when att = %.1f', attenuations(att)));
%     
%     subplot(1, 2, 2);
%     for m = 1 : length(applied_forces)
%         hold on;
%         plot(modeled_t{m}, modeled_f{m});
%     end
%     title(sprintf('force when att = %.1f', attenuations(att)));
%     
% end



% DEPRECATED: converted to function dadt for easy integration
% Transfer functions
% a1_dot + ((1/tau_act1)*(beta1 + (1-beta1)*EMG(t-t_off))) * a1(t) = (1/tau_act1) * EMG(t-t_off)
% a2_dot + ((1/tau_act2)*(beta2 + (1-beta2)*a1(t))) * a2(t) = (1/tau_act2) * a1(t)
% a3_dot + ((1/tau_act3)*(beta3 + (1-beta3)*a3(t))) * a3(t) = (1/tau_act3) * a2(t)
function [a_dot_slow, a_dot_fast] = activation_transfer(a, tau, b)
    % Returns a_dot as vector [a2_dot, a3_dot]
    % where a1_dot is transfer function of the whole muscle, a2_dot is the
    % transfer function of slow fibers, and a3_dot is the transfer function
    % of the fast fibers.
    % Expects tau_act as vector [tau_act_slow, tau_act_fast],
    % b represents beta as vector [beta_slow, beta_fast],
    % and a as vector (a_whole(t), a_slow(t), a_fast(t)]
    %a_dot(1) = (1/tau_act(1))*EMG - ((1/tau_act(1))*(b(1)+(1-b(1))*EMG))*a(1);
    %not including a_dot of whole muscle in order to use arbitrary
    %activation pattern for testing
    a_dot_slow = (1/tau(1))*a(1) - ((1/tau(1))*(b(1)+(1-b(1))*a(1)))*a(2);
    a_dot_fast = (1/tau(2))*a(2) - ((1/tau(2))*(b(2)+(1-b(2))*a(2)))*a(3);
end

% DEPRECATED: incorrect, replaced with muscle_force() that takes v as input
% instead of inaccurately determing v inversely from F and requiring
% direction as char array
% Total muscle force
% Fm = c(F_f + F_p(l)) * cos(theta)
% Where F_f (F_f-hat in paper) is active component of the muscle fiber force,
% F_p(l) (F_p-hat(l) in paper) is passive component of muscle fiber force,
% constant c reflects the maximum isometric force generated by muscle,
% and theta is pennation angle.
function F_m = total_muscle_force(a_slow, a_fast, l, l_opt, v_0, k, c, theta, F_applied, direction)
    v = velocity_from_force(F_applied, v_0, k, direction);
    F_f = total_active_force(a_slow, a_fast, l/l_opt, v, v_0, k);
    F_p = force_length_passive(l/l_opt);
    F_m = c * (F_f + F_p) * cos(theta);
end

% DEPRECATED: dependency of total_muscle_force() and wasn't necessarily
% accurate to deduce velocity in this way
% Force from velocity calculated by inverting force-velocity relationship
% above for the purpose of determine new length
% Requires knowledge of concentric or eccentric muscle activity because
% negative velocity corresponds to concentric or shortening movement
function v = velocity_from_force(F, v_0, k, direction)
    % For isometric case, just pass F as 0 because direction should be
    % passed as 'isometric' yielding desired output of velocity = 0 since
    % muscle is not contracting or elongating
    assert((strcmp(direction, 'concentric') || ...
        strcmp(direction, 'eccentric') || ...
        strcmp(direction, 'isometric')), ...
        'velocity_from_force: must pass direction as eccentric or concentric');
    % Using mean curvature of slow and fast fibers because not specified
    % how to use them separately in the papers researched.
    if strcmp(direction, 'concentric')
        v = ((1 - F) * (v_0 * mean(k))) / (mean(k) - F);
    elseif strcmp(direction, 'eccentric')
        v = (2 - 2 * F) / ((1/v_0) + ((3*7.56)/(v_0*mean(k))) - ((2*7.56*F)/(v_0*mean(k))));
    else
        v = 0;
    end
end

% DEPRECATED: were used for sanity checks, no longer necessary in script
function F_f = total_active_force_slow(a_slow, l, v, v_0, k)
    F_f = a_slow * force_length_active(l) * force_velocity(v, v_0, k(1));
end
function F_f = total_active_force_fast(a_fast, l, v, v_0, k)
    F_f = a_fast * force_length_active(l) * force_velocity(v, v_0, k(2));
end